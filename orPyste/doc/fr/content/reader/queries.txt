this::
    date = 2017-02-17


============================
Faire des recherches ciblées
============================

Nous allons considérer le fichier ¨peuf suivant afin d'expliquer comment effectuer des recherches ciblées. Ce fichier est supposé admettre path::``user/example.peuf`` pour chemin complet et le ``utf-8`` pour encodage.

orpyste::
    bloc_1::
        test::
            a = 1 + 9
            b <>  2
            c = 3 and 4

    bloc_2::
        sous_bloc::
            sous_sous_bloc::
                verb::
                    ligne 1
                    ligne 2
                    ligne 3


Rappelons que les différents blocs sont identifiés via leur "chemin" : ici nous avons ``bloc_1/test`` et ``bloc_2/sous_bloc/sous_sous_bloc/verbatim``. La recherche ciblée se fait donc via des requêtes sur ces "chemins" en une utilisant une syntaxe mélangeant s'inspirant de celles des ¨regex_frs ¨python et de certains motifs à la sauce ¨unix. Voici un exemple d'utilisation où au lieu de ``for onedata in datas:...`` nous utilisons ``for onedata in datas[query]:...`` pour indiquer notre requête de recherche.

python::
    from pathlib import Path
    from orpyste.data import Read

    with Read(
        content = Path("user/example.peuf"),
        mode    = {
            "container"    : ":default:",
            "keyval:: = <>": "test",
            "verbatim"     : "verb"
        }
    ) as datas:
        for query in [
            "bloc_1/test",
            "**",
            "bloc_1/*",
        ]:
            title = "Requête : {0}".format(query)
            hrule = "="*len(title)

            print("", hrule, title, hrule, sep = "\n")

            for onedata in datas[query]:
                if onedata.isblock():
                    print(
                        "",
                        "--- {0} [{1}] ---".format(
                            onedata.querypath,
                            onedata.mode
                        ),
                        sep = "\n"
                    )

                elif onedata.isdata():
                    for data_rtu in onedata.yrtu():
                        print(data_rtu)


Expliquons chaque requête
((
    Pour plus de fonctionnalités, se reporter à la ¨doc technique de la fonction ``data.regexify``.
)).

    1) ``"bloc_1/test"`` est un chemin exact et unique.

    1) ``**`` indique n'importe quel caractère y compris la valeur de l'argument ``sep`` . Cet argument vaut ``/`` par défaut.

    1) ``"*"`` permet de rechercher tout caractère sauf la valeur de l'argument ``sep``. Donc ici `"bloc_1/*"`` va juste repérer le bloc ``"bloc_1/test"``.


Nous comprenons pourquoi maintenant qu'une fois lancé dans un terminal, le code affiche ce qui suit.

term::
    =====================
    Requête : bloc_1/test
    =====================

    --- bloc_1/test [keyval] ---
    (4, 'a', '=', '1 + 9')
    (5, 'b', '<>', '2')
    (6, 'c', '=', '3 and 4')

    ============
    Requête : **
    ============

    --- bloc_1/test [keyval] ---
    (4, 'a', '=', '1 + 9')
    (5, 'b', '<>', '2')
    (6, 'c', '=', '3 and 4')

    --- bloc_2/sous_bloc/sous_sous_bloc/verb [verbatim] ---
    (12, 'ligne 1')
    (13, 'ligne 2')
    (14, 'ligne 3')

    ==================
    Requête : bloc_1/*
    ==================

    --- bloc_1/test [keyval] ---
    (4, 'a', '=', '1 + 9')
    (5, 'b', '<>', '2')
    (6, 'c', '=', '3 and 4')


info::
    Ce qui précède fonctionne aussi avec la classe ``ReadBlock``, qui est une sous-classe de ``Read``.


info::
    Avec la classe ``Read``, vous pouvez utiliser ``onedata.rtu`` pour récuperer la donnée en cours de lecture. Ceci permet d'éviter l'utilisation, lourde ici, de l'itérateur ``yrtu``
    ((
        Par contre, dans le cas de la classe ``ReadBlock``, la méthode-attribut ``rtu`` n'est pas très sympathique.
    ))


Vous disposez si besoin de l'attribut ``nbline`` des classes ``Read`` et ``ReadBlock`` pour récupérer le numéro de ligne d'un bloc de données, mais pas celui du bloc conteneur. Voici comment faire.

python::
    from pathlib import Path
    from orpyste.data import ReadBlock

    with ReadBlock(
        content = Path("user/example.peuf"),
        mode    = {
            "container"    : ":default:",
            "keyval:: = <>": "test",
            "verbatim"     : "verb"
        }
    ) as datas:
        for onedata in datas["**"]:
            if onedata.isblock():
                print(
                    "{0} : ligne n°{1}".format(
                        onedata.querypath,
                        onedata.nbline
                    )
                )


Ceci nous fournit les informations suivantes.

term::
    bloc_1/test : ligne n°2
    bloc_2/sous_bloc/sous_sous_bloc/verb : ligne n°10
